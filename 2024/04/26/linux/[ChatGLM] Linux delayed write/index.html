<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=true"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'true');
</script>
<!-- End Google Analytics -->

  
<!-- Global site tag (gtag.js) - Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?true";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- End Baidu Analytics -->

  
<!-- Gaug.es Analytics -->
<script>
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', 'true');
    t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
    t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>
<!-- End Gaug.es Analytics -->


  
  <title>Linux delayed write | Systemcall Station</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="User: As a professional file system expert, please describe in detail the process of delayed write in the Linux kernel and list five main scenarios. ChatGLM: In the Linux kernel, delayed write is an o">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux delayed write">
<meta property="og:url" content="https://neutionwei.github.io/2024/04/26/linux/[ChatGLM]%20Linux%20delayed%20write/index.html">
<meta property="og:site_name" content="Systemcall Station">
<meta property="og:description" content="User: As a professional file system expert, please describe in detail the process of delayed write in the Linux kernel and list five main scenarios. ChatGLM: In the Linux kernel, delayed write is an o">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-04-26T03:13:43.000Z">
<meta property="article:modified_time" content="2024-04-26T03:26:08.299Z">
<meta property="article:author" content="Neutionwei">
<meta property="article:tag" content="delayed write">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Systemcall Station" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon/music.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/images/banner/reona.jpg" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Systemcall Station </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/images/avatar/reona.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Neutionwei </div>
      <div class="dot"></div>
      <div class="subtitle">An embedded geek & music enthusiast </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/Neutionwei" title="CSDN"><i class="fa-solid fa-blog"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/NeutionWei" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Categories</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/ai/">
                ai
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/git/">
                git
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/headphone/">
                headphone
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/categories/image/">
                image
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/categories/linux/">
                linux
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/categories/python3/">
                python3
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/categories/rk3399/">
                rk3399
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/boot/" rel="tag">boot</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/chatgpt/" rel="tag">chatgpt</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/delayed-write/" rel="tag">delayed write</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/free/" rel="tag">free</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/headphone-parameters/" rel="tag">headphone parameters</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/jpeg/" rel="tag">jpeg</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/over-ear-headphone/" rel="tag">over-ear headphone</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/rsync/" rel="tag">rsync</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/yuv/" rel="tag">yuv</a></li></ul>
    </div>
  </div>


    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-linux/[ChatGLM] Linux delayed write" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        Linux delayed write
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-04-26T03:13:43.000Z" itemprop="datePublished">2024-04-26</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/linux/">linux</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            12k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/delayed-write/" rel="tag">delayed write</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p><strong>User:</strong> As a professional file system expert, please describe in detail the process of delayed write in the Linux kernel and list five main scenarios.</p>
<p><strong>ChatGLM:</strong> In the Linux kernel, delayed write is an optimization mechanism that allows the system to aggregate multiple write operations, reducing the actual number of I&#x2F;O operations on the storage device. This mechanism can improve the overall performance of the system by decreasing the frequency of disk I&#x2F;O and better utilizing the performance benefits of sequential disk writes. Here is the process of delayed write in the Linux kernel and five main scenarios:</p>
<h3 id="Delayed-Write-Process"><a href="#Delayed-Write-Process" class="headerlink" title="Delayed Write Process:"></a>Delayed Write Process:</h3><ol>
<li><strong>Write Operation Initiation</strong>: When an application performs a write operation, the data is first written to the page cache in memory, instead of being immediately written to disk.</li>
<li><strong>Dirty Page Marking</strong>: The data pages that are written to the page cache are marked as “dirty pages,” indicating that their content in memory is different from their content on disk.</li>
<li><strong>Writeback Trigger</strong>: Dirty pages accumulate in the page cache for a period of time, or when the system needs to free up memory, the kernel’s writeback mechanism (pdflush or flusher threads) will write the dirty pages to disk.</li>
<li><strong>Write to Disk</strong>: The writeback process writes the dirty pages to disk and updates the relevant metadata. This process can be synchronous or asynchronous, depending on the system configuration and application requirements.</li>
<li><strong>Dirty Page Cleanup</strong>: Once the dirty pages have been successfully written to disk, they are marked as clean, and the page cache can be reused for other purposes.</li>
</ol>
<h3 id="Five-Main-Scenarios"><a href="#Five-Main-Scenarios" class="headerlink" title="Five Main Scenarios:"></a>Five Main Scenarios:</h3><ol>
<li><strong>File System Caching</strong>: When an application writes to a file, the data is buffered in the memory’s page cache. These data are written back to disk at some point in the future, possibly through regular synchronization or when the cache reaches a certain threshold.</li>
<li><strong>Journaling File Systems</strong>: For file systems that use a journal (such as ext3, ext4, XFS, etc.), changes to metadata and data are first recorded in the journal. These changes are written back to disk when the transaction is committed, improving file system performance and reliability.</li>
<li><strong>Database Write Operations</strong>: Database management systems (such as MySQL, PostgreSQL) often use their own buffer pools and write-ahead logs (WAL) to optimize write operations. These systems will write data from the buffer pool to disk at the appropriate time.</li>
<li><strong>Virtual Memory Swapping</strong>: When the system’s memory is low, the Linux kernel may choose to swap out less frequently accessed memory pages to disk. This process involves delayed write, as the swapped pages may stay in the swap cache for some time before being written to disk.</li>
<li><strong>Network File Systems</strong>: In network file systems (such as NFS), the client may cache writes to the server. These writes are then sent to the server at a later time, reducing the number of network communications and improving performance.<br>The delayed write mechanism is a crucial performance optimization feature in the Linux kernel, allowing for better management of data writes to disk and reducing the load on storage devices. However, it also means that in the event of a system crash, data that has not been written to disk may be lost, so careful configuration of synchronization and backup strategies is necessary to ensure data safety.</li>
</ol>
<hr>
<p><strong>User:</strong> What are the interfaces in Linux for synchronous write operations, and can you compare their advantages and disadvantages?</p>
<p><strong>ChatGLM:</strong> In Linux, there are several interfaces available for performing synchronous write operations, ensuring that data is immediately written to disk. Here’s a comparison of some of the main interfaces and their advantages and disadvantages:</p>
<ol>
<li><strong>fsync()</strong><ul>
<li><strong>Description</strong>: The <code>fsync()</code> system call synchronizes the on-disk state of a file, ensuring that all data and metadata changes are written to disk.</li>
<li><strong>Advantages</strong>: Ensures that all changes to a file are durable, suitable for critical data同步.</li>
<li><strong>Disadvantages</strong>: Each <code>fsync()</code> call can incur significant performance overhead due to disk I&#x2F;O.</li>
</ul>
</li>
<li><strong>fdatasync()</strong><ul>
<li><strong>Description</strong>: Similar to <code>fsync()</code>, but may not synchronize file metadata unless necessary, potentially reducing unnecessary disk I&#x2F;O.</li>
<li><strong>Advantages</strong>: Can be more efficient than <code>fsync()</code> if the file metadata has not changed.</li>
<li><strong>Disadvantages</strong>: If file metadata changes, the effectiveness is the same as <code>fsync()</code>.</li>
</ul>
</li>
<li><strong>sync()</strong><ul>
<li><strong>Description</strong>: The <code>sync()</code> system call triggers the writeback of all dirty pages in the system’s page cache to disk.</li>
<li><strong>Advantages</strong>: Can flush all pending writes in a single operation, useful before shutdown or critical operations.</li>
<li><strong>Disadvantages</strong>: Does not wait for the disk write to complete; for guaranteed synchronization, <code>fsync()</code> or<code>fdatasync()</code> may be needed.</li>
</ul>
</li>
<li><strong>syncfs()</strong><ul>
<li><strong>Description</strong>: Similar to <code>sync()</code>, but only affects the specified file system.</li>
<li><strong>Advantages</strong>: Can synchronize specific file systems without affecting others.</li>
<li><strong>Disadvantages</strong>: Does not wait for the disk write to complete; for guaranteed synchronization, <code>fsync()</code> or <code>fdatasync()</code> may be needed.</li>
</ul>
</li>
<li><strong>open() with O_SYNC flag</strong><ul>
<li><strong>Description</strong>: When opening a file with the <code>O_SYNC</code> flag, all writes to the file are automatically synchronized to disk.</li>
<li><strong>Advantages</strong>: Provides strict data consistency for applications that require it.</li>
<li><strong>Disadvantages</strong>: Significantly reduces write performance as each write requires disk confirmation.</li>
</ul>
</li>
<li><strong>pwrite() with SYNC_IO flag</strong><ul>
<li><strong>Description</strong>: When using <code>pwrite()</code> with the <code>SYNC_IO</code> flag, the write operation is synchronized to disk.</li>
<li><strong>Advantages</strong>: Offers fine-grained control, allowing synchronous writes when needed.</li>
<li><strong>Disadvantages</strong>: Similar to <code>fsync()</code>, each synchronous write operation has performance implications.</li>
</ul>
</li>
</ol>
<p>These interfaces provide different levels of control over synchronous writes in Linux, and the choice of which to use depends on the application’s requirements for data consistency and performance. Typically, for non-critical data, asynchronous writes can be used to improve performance, while for critical data, synchronous writes are necessary to ensure data reliability.</p>
<hr>
<p><strong>User:</strong> What is file metadata?</p>
<p><strong>ChatGLM:</strong> File metadata refers to information that describes the characteristics of a file itself, rather than the content of the file. It is managed by the file system and provides information necessary for the management and interpretation of file data.</p>
<p>Metadata typically includes information such as:</p>
<ol>
<li><strong>File size</strong>: The amount of storage space the file occupies.</li>
<li><strong>Creation time</strong>: The date and time when the file was created.</li>
<li><strong>Last modification time</strong>: The date and time when the file was last modified.</li>
<li><strong>Last access time</strong>: The date and time when the file was last accessed.</li>
<li><strong>File permissions</strong>: Define the access permissions for different users (read, write, execute).</li>
<li><strong>File owner</strong>: The user ID of the file owner.</li>
<li><strong>File group</strong>: The group ID of the file’s owner group.</li>
<li><strong>File type</strong>: Indicates whether the file is a regular file, directory, symbolic link, etc.</li>
<li><strong>inode number</strong>: A unique identifier assigned by the file system to each file.</li>
<li><strong>Link count</strong>: The number of hard links to the file, i.e., the number of file names pointing to the same inode.</li>
<li><strong>File block mapping</strong>: The specific location on the disk where the file data is stored.</li>
<li><strong>Extended attributes</strong>: Such as security labels, additional permission information, etc.</li>
</ol>
<p>Metadata is crucial for the proper functioning of a file system, as it allows the operating system and applications to retrieve and manage files. For example, file permissions metadata determines which users can read, write, or execute a file; file size and block mapping information allow for quick location of file content; and timestamps can be used for backup strategies and file version control.<br>In Linux, you can view file metadata using commands like <code>ls -l</code> and <code>stat</code>. For example, the <code>stat</code> command can provide detailed information about a file, including size, creation time, modification time, access time, permissions, and more.</p>
<hr>
<p><strong>User:</strong> What is the difference between the <code>fflush</code> interface and the synchronous write interfaces (like <code>fsync</code>, <code>fdatasync</code>, <code>sync</code>) you previously mentioned?</p>
<p><strong>ChatGLM:</strong> <code>fflush</code> is a function from the C standard library that handles file stream buffers. Before discussing the differences between <code>fflush</code> and the synchronous write interfaces, it’s important to understand the distinction between file stream buffers and file system caches (page caches).</p>
<h3 id="File-Stream-Buffers-File-Stream-Buffer"><a href="#File-Stream-Buffers-File-Stream-Buffer" class="headerlink" title="File Stream Buffers (File Stream Buffer)"></a>File Stream Buffers (File Stream Buffer)</h3><p>When a program uses standard I&#x2F;O library functions (from <code>stdio.h</code>) for file read and write operations, the data is first written to a file stream buffer. This buffer is part of the user space and is designed to reduce the number of system calls and disk I&#x2F;O operations. Data in the buffer is only flushed to the file system cache under certain conditions.</p>
<h3 id="File-System-Cache-Page-Cache"><a href="#File-System-Cache-Page-Cache" class="headerlink" title="File System Cache (Page Cache)"></a>File System Cache (Page Cache)</h3><p>The file system cache is part of the kernel space and caches file data and metadata. When an application writes data, it may first be written to this cache before the kernel decides when to write these data to the disk.</p>
<h3 id="fflush-Function"><a href="#fflush-Function" class="headerlink" title="fflush Function"></a><code>fflush</code> Function</h3><p>The <code>fflush</code> function is used to force the file stream buffer to flush its contents to the file system cache. Calling <code>fflush</code> does not immediately trigger data to be written to disk; it only ensures that the data has been moved from the user-space buffer to the kernel-space file system cache. To ensure that data is actually written to disk, you should call <code>fsync</code> or <code>fdatasync</code> after <code>fflush</code>.</p>
<h3 id="Synchronous-Write-Interfaces"><a href="#Synchronous-Write-Interfaces" class="headerlink" title="Synchronous Write Interfaces"></a>Synchronous Write Interfaces</h3><p>The synchronous write interfaces (<code>fsync</code>, <code>fdatasync</code>, <code>sync</code>) are system calls that ensure data in the file system cache is written to disk. <code>fsync</code> and <code>fdatasync</code> are specific to a file or file descriptor, while <code>sync</code> affects the file system cache of the entire system.</p>
<h3 id="Summary-of-Differences"><a href="#Summary-of-Differences" class="headerlink" title="Summary of Differences"></a>Summary of Differences</h3><ul>
<li><code>fflush</code> only moves data from the file stream buffer to the file system cache; it does not guarantee data is written to disk.</li>
<li>Synchronous write interfaces (<code>fsync</code>, <code>fdatasync</code>, <code>sync</code>) ensure that data in the file system cache is written to disk, ensuring data durability.<br>Therefore, if you want to ensure that data is safely stored on the disk, you should call <code>fflush</code> followed by <code>fsync</code> or <code>fdatasync</code>. For example, a typical scenario is to call <code>fflush(stdout)</code> after writing critical data, and then call <code>fsync(fileno(stdout))</code> to ensure the data is securely stored on disk.</li>
</ul>
<hr>
<p>在Linux内核中，延迟写（deferred write）是一种优化机制，它允许系统将多个写操作聚集在一起，减少对存储设备的实际I&#x2F;O操作次数。这种机制可以提高系统的整体性能，因为它减少了磁盘I&#x2F;O的频率，并且可以更好地利用磁盘的顺序写性能。以下是Linux内核中延迟写的过程，以及五个主要场景的说明：</p>
<h3 id="延迟写过程："><a href="#延迟写过程：" class="headerlink" title="延迟写过程："></a>延迟写过程：</h3><ol>
<li><strong>写操作发起</strong>：当应用程序执行写操作时，数据首先被写入到页缓存（page cache）中，而不是立即写入磁盘。</li>
<li><strong>脏页标记</strong>：写入页缓存的数据页被标记为“脏页”，表示它们在内存中的内容与磁盘上的内容不同。</li>
<li><strong>回写触发</strong>：脏页在页缓存中积累一段时间后，或者当系统内存不足需要释放页面时，内核的回写机制（pdflush或flusher threads）会将脏页写入磁盘。</li>
<li><strong>写回磁盘</strong>：回写进程将脏页写入磁盘，并更新相关的元数据。这个过程可以是同步的或异步的，取决于系统的配置和应用程序的需求。</li>
<li><strong>脏页清理</strong>：一旦脏页被成功写入磁盘，它们就被标记为干净，页缓存中的这些页面可以被重新用于其他目的。</li>
</ol>
<h3 id="五个主要场景："><a href="#五个主要场景：" class="headerlink" title="五个主要场景："></a>五个主要场景：</h3><ol>
<li><strong>文件系统缓存</strong>：当应用程序写入文件时，数据首先被缓存在内存中的页缓存中。这些数据在未来的某个时间点被回写到磁盘，可能是通过定期同步或当缓存达到一定阈值时。</li>
<li><strong>日志文件系统</strong>：对于使用日志的文件系统（如ext3、ext4、XFS等），元数据和数据的更改首先被记录在日志中。这些更改在事务提交时被延迟写回磁盘，以提高文件系统的性能和可靠性。</li>
<li><strong>数据库写操作</strong>：数据库管理系统（如MySQL、PostgreSQL）通常使用自己的缓冲池和写前日志（WAL）来优化写操作。这些系统会在合适的时机将数据从缓冲池延迟写回磁盘。</li>
<li><strong>虚拟内存交换</strong>：当系统内存不足时，Linux内核可能会选择将不常访问的内存页交换到磁盘上。这个过程涉及到延迟写，因为交换页在被实际写入磁盘之前可能会在交换缓存中停留一段时间。</li>
<li><strong>网络文件系统</strong>：在网络文件系统（如NFS）中，客户端可能会缓存对服务器的写操作，并在稍后某个时间点将它们发送到服务器。这减少了网络通信的次数，提高了性能。</li>
</ol>
<p>延迟写机制是Linux内核中一个重要的性能优化特性，它通过合理地管理数据写入磁盘的时机，减少了磁盘I&#x2F;O的负载，并提高了系统的吞吐量和响应速度。然而，这也意味着在系统崩溃时，可能会丢失在页缓存中尚未写入磁盘的数据，因此需要仔细配置同步和备份策略来保证数据的安全性。</p>
<hr>
<p>在Linux系统中，提供了多个接口用于执行同步写操作，以确保数据被立即写入磁盘。以下是一些常用的接口及其优缺点：</p>
<ol>
<li><strong>fsync()</strong><ul>
<li><strong>描述</strong>：<code>fsync()</code>系统调用会同步一个文件的磁盘状态，确保所有对该文件的数据和元数据的更改都被写入磁盘。</li>
<li><strong>优点</strong>：可以确保文件的所有更改被持久化，适合关键数据的同步。</li>
<li><strong>缺点</strong>：每个<code>fsync()</code>调用都会触发磁盘I&#x2F;O，性能开销较大。</li>
</ul>
</li>
<li><strong>fdatasync()</strong><ul>
<li><strong>描述</strong>：<code>fdatasync()</code>类似于<code>fsync()</code>，但它只同步文件的数据部分，不强制更新文件的元数据，除非必要。</li>
<li><strong>优点</strong>：如果文件元数据没有改变，可以减少不必要的磁盘I&#x2F;O。</li>
<li><strong>缺点</strong>：如果文件元数据发生变化，<code>fdatasync()</code>的效果与<code>fsync()</code>相同。</li>
</ul>
</li>
<li><strong>sync()</strong><ul>
<li><strong>描述</strong>：<code>sync()</code>系统调用会触发将所有脏页缓存（包括文件数据和元数据）写入磁盘的操作。</li>
<li><strong>优点</strong>：可以一次性同步所有脏页，适合在关机或执行重要操作前使用。</li>
<li><strong>缺点</strong>：<code>sync()</code>不会等待磁盘写操作完成，如果需要确保数据确实写入磁盘，需要跟随一个<code>fsync()</code>或<code>fdatasync()</code>调用。</li>
</ul>
</li>
<li><strong>syncfs()</strong><ul>
<li><strong>描述</strong>：<code>syncfs()</code>系统调用会同步一个指定文件系统的磁盘状态，类似于<code>sync()</code>，但只影响指定的文件系统。</li>
<li><strong>优点</strong>：可以针对特定文件系统进行同步，而不影响其他文件系统。</li>
<li><strong>缺点</strong>：与<code>sync()</code>一样，不会等待磁盘写操作完成。</li>
</ul>
</li>
<li><strong>open() 的 O_SYNC 标志</strong><ul>
<li><strong>描述</strong>：在打开文件时使用<code>O_SYNC</code>标志，会使得所有对该文件的写操作都自动同步到磁盘。</li>
<li><strong>优点</strong>：对于需要严格数据一致性的应用程序，可以保证每次写操作都是同步的。</li>
<li><strong>缺点</strong>：会显著降低写操作的性能，因为每次写都需要等待磁盘确认。</li>
</ul>
</li>
<li><strong>pwrite() 的 SYNC_IO 标志</strong><ul>
<li><strong>描述</strong>：在使用<code>pwrite()</code>系统调用进行写入时，如果指定了<code>SYNC_IO</code>标志，写操作会同步到磁盘。</li>
<li><strong>优点</strong>：提供了细粒度的控制，可以在需要时选择性地执行同步写操作。</li>
<li><strong>缺点</strong>：与<code>fsync()</code>类似，每个同步写操作都会带来性能开销。<br>这些接口在确保数据持久化方面各有优缺点，选择合适的接口取决于应用程序对数据一致性和性能的需求。通常，对于非关键数据，可以采用异步写操作以提高性能，而对于关键数据，则应使用同步写操作以确保数据的可靠性。</li>
</ul>
</li>
</ol>
<hr>
<p>文件的元数据（Metadata）是指描述文件自身特征的信息，它不包含文件数据的内容，但提供了文件数据的管理和解释所需的信息。元数据通常由文件系统管理，并且在文件创建、修改或删除时自动更新。文件的元数据包括但不限于以下内容：</p>
<ol>
<li><strong>文件大小</strong>：文件占据的存储空间大小。</li>
<li><strong>创建时间</strong>：文件被创建的日期和时间。</li>
<li><strong>最后修改时间</strong>：文件最后被修改的日期和时间。</li>
<li><strong>最后访问时间</strong>：文件最后被访问的日期和时间。</li>
<li><strong>文件权限</strong>：定义了不同用户对文件的访问权限（读、写、执行）。</li>
<li><strong>文件所有者</strong>：文件的所有者用户ID。</li>
<li><strong>文件所属组</strong>：文件的所有者组ID。</li>
<li><strong>文件类型</strong>：指示文件是常规文件、目录、符号链接等。</li>
<li><strong>inode号码</strong>：文件系统分配给文件的唯一标识符。</li>
<li><strong>链接计数</strong>：硬链接的数量，即有多少文件名指向这个inode。</li>
<li><strong>文件块映射</strong>：文件数据存储在磁盘上的具体位置。</li>
<li><strong>扩展属性</strong>：如安全性标签、额外的权限信息等。<br>元数据对于文件系统的正常运行至关重要，因为它允许操作系统和应用程序检索和管理文件。例如，文件权限元数据决定了哪些用户可以读取、写入或执行文件；文件大小和块映射信息允许快速定位文件内容；而时间戳则可以用于备份策略和文件版本控制。<br>在Linux系统中，可以通过<code>ls -l</code>、<code>stat</code>等命令查看文件的元数据。例如，使用<code>stat</code>命令可以查看文件的详细信息，包括大小、创建时间、修改时间、访问时间、权限等元数据。</li>
</ol>
<hr>
<p><code>fflush</code>是C标准库函数，用于处理文件流（file streams）的缓冲区。在讨论<code>fflush</code>与前面提到的同步写接口（如<code>fsync</code>、<code>fdatasync</code>、<code>sync</code>等）的区别之前，需要明确文件流缓冲区和文件系统缓存（页缓存）的区别。</p>
<h3 id="文件流缓冲区（File-Stream-Buffer）"><a href="#文件流缓冲区（File-Stream-Buffer）" class="headerlink" title="文件流缓冲区（File Stream Buffer）"></a>文件流缓冲区（File Stream Buffer）</h3><p>当程序使用标准I&#x2F;O库（如<code>stdio.h</code>中的函数）进行文件读写时，数据会首先被写入到文件流缓冲区中。这个缓冲区是用户空间的一部分，它是为了减少系统调用次数和磁盘I&#x2F;O操作而设计的。只有在特定情况下，缓冲区中的数据才会被刷新（flushed）到文件系统缓存中。</p>
<h3 id="文件系统缓存（Page-Cache）"><a href="#文件系统缓存（Page-Cache）" class="headerlink" title="文件系统缓存（Page Cache）"></a>文件系统缓存（Page Cache）</h3><p>文件系统缓存是内核空间的一部分，它缓存了文件的数据和元数据。当应用程序写入数据时，数据可能会先被写入到这个缓存中，然后由内核决定何时将这些数据写入磁盘。</p>
<h3 id="fflush函数"><a href="#fflush函数" class="headerlink" title="fflush函数"></a><code>fflush</code>函数</h3><p><code>fflush</code>函数的作用是强制将文件流缓冲区中的数据刷新到文件系统缓存中。调用<code>fflush</code>并不会立即触发数据写入磁盘，它只是确保数据已经从用户空间的缓冲区移动到了内核空间的文件系统缓存中。如果要确保数据确实写入磁盘，需要在<code>fflush</code>之后调用同步写接口（如<code>fsync</code>或<code>fdatasync</code>）。</p>
<h3 id="同步写接口"><a href="#同步写接口" class="headerlink" title="同步写接口"></a>同步写接口</h3><p>同步写接口如<code>fsync</code>、<code>fdatasync</code>和<code>sync</code>是系统调用，它们的作用是确保文件系统缓存中的数据被写入磁盘。<code>fsync</code>和<code>fdatasync</code>针对特定文件或文件描述符，而<code>sync</code>则影响整个系统的文件系统缓存。</p>
<h3 id="总结区别"><a href="#总结区别" class="headerlink" title="总结区别"></a>总结区别</h3><ul>
<li><code>fflush</code>只是将文件流缓冲区中的数据移动到文件系统缓存，不保证数据写入磁盘。</li>
<li>同步写接口（<code>fsync</code>、<code>fdatasync</code>、<code>sync</code>）确保文件系统缓存中的数据被写入磁盘，保证数据的持久化。</li>
</ul>
<p>因此，如果你想要确保文件数据确实写入磁盘，你应该在调用<code>fflush</code>之后使用<code>fsync</code>或<code>fdatasync</code>。例如，一个典型的场景是在写入关键数据后调用<code>fflush(stdout)</code>，然后调用<code>fsync(fileno(stdout))</code>以确保数据安全地存储在磁盘上。</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left  disabled "
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/04/25/linux/rsync%20%E7%94%A8%E6%B3%95%E6%95%99%E7%A8%8B/"
      title="rsync 用法教程"
     >

    <p class="title-text">
      
        rsync 用法教程
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>




  <script src="https://cdn.staticfile.org/twikoo/1.6.26/twikoo.all.min.js"></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">Comments </div>
    </div>
    <div id="tcomment"></div>
  </div>
  <script>
      twikoo.init({
          envId: '',
          el: '#tcomment',
          region: '',
          path: 'location.pathname',
          lang: '',
      })
  </script>
  

    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 Neutionwei<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
